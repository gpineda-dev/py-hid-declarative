from abc import ABC, abstractmethod
from hid_declarative.parser import HIDParser
from hid_declarative.profile import HIDProfile
from hid_declarative.spec.lookup import HIDLookup
from hid_declarative.spec.tags import ItemTag

class Exporter(ABC):
    @abstractmethod
    def export(self, data: bytes, profile: HIDProfile) -> str:
        """Transforme le blob binaire en code source."""
        pass

    def _comment_item(self, item) -> str:
        """Génère un commentaire lisible pour un Item donné."""
        pass

# --- Implémentation C ---
class CExporter(Exporter):
    def export(self, data: bytes, profile: HIDProfile) -> str:
        var_name = profile.variable_name or "hid_report_desc"
        var_name_len = f"{var_name}_len"
        
        lines = [
            f"/* Generated by hid-declarative for {profile.name} */",
            "#include <stdint.h>",
            "",
            f"const uint8_t {var_name}[] = {{",
        ]
        
        # 1. On re-parse le binaire pour comprendre sa structure
        parser = HIDParser()
        items = parser.parse(data)
        
        # État pour l'affichage intelligent (comme dans inspect)
        indent_level = 0
        current_usage_page = 0
        
        for item in items:
            # A. Génération des octets C (Gauche)
            item_bytes = item.to_bytes()
            hex_str = ", ".join(f"0x{b:02X}" for b in item_bytes) + ","
            
            # B. Génération du Commentaire (Droite)
            comment = ""
            item_name = item.__class__.__name__.replace("Item", "")
            
            # Gestion de l'indentation visuelle dans les commentaires
            prefix_indent = "  " * indent_level
            
            if item.tag == ItemTag.COLLECTION:
                col_type = HIDLookup.get_collection_type(item.data)
                comment = f"Collection ({col_type})"
                indent_level += 1 # On indente pour les suivants
            
            elif item.tag == ItemTag.END_COLLECTION:
                indent_level = max(0, indent_level - 1) # On désindente avant d'afficher
                prefix_indent = "  " * indent_level
                comment = "End Collection"
                
            elif item.tag == ItemTag.USAGE_PAGE:
                current_usage_page = item.data
                page_name = HIDLookup.get_page_name(item.data)
                comment = f"Usage Page ({page_name})"
                
            elif item.tag in (ItemTag.USAGE, ItemTag.USAGE_MIN, ItemTag.USAGE_MAX):
                # On utilise la page courante pour résoudre le nom
                usage_name = HIDLookup.get_usage_name(current_usage_page, item.data)
                comment = f"{item_name} ({usage_name})"
                
            else:
                # Cas par défaut : Nom + Valeur brute
                val_str = str(item.data)
                if isinstance(item.data, list): val_str = "..."
                comment = f"{item_name} ({val_str})"

            # C. Assemblage aligné
            # {bytes:<40} assure que les // sont tous alignés verticalement
            lines.append(f"    {hex_str:<40} // {prefix_indent}{comment}")
            
        lines.append("};")
        lines.append(f"const unsigned int {var_name_len} = sizeof({var_name});")
        
        return "\n".join(lines)
    
    

class RustExporter(Exporter):
    def export(self, data: bytes, profile: HIDProfile) -> str:
        
        var_name = profile.variable_name or "HID_REPORT_DESC"
        var_name = var_name.upper()
        
        lines = [
            f"// Generated by hid-declarative for {profile.name}",
            "",
            f"pub const {var_name}: [u8; {len(data)}] = [",
        ]
        
        # Formatage des octets en lignes de 12
        byte_lines = []
        for i in range(0, len(data), 12):
            chunk = data[i:i+12]
            hex_str = ", ".join(f"0x{b:02X}" for b in chunk)
            byte_lines.append(f"    {hex_str},")
        
        lines.extend(byte_lines)
        lines.append("];")
        
        return "\n".join(lines)
    

class GoExporter(Exporter):
    def export(self, data: bytes, profile: HIDProfile) -> str:
        
        var_name = profile.variable_name or "HIDReportDesc"
        
        lines = [
            f"// Generated by hid-declarative for {profile.name}",
            "",
            f"var {var_name} = []byte{{",
        ]
        
        # Formatage des octets en lignes de 12
        byte_lines = []
        for i in range(0, len(data), 12):
            chunk = data[i:i+12]
            hex_str = ", ".join(f"0x{b:02X}" for b in chunk)
            byte_lines.append(f"    {hex_str},")
        
        lines.extend(byte_lines)
        lines.append("}")
        
        return "\n".join(lines)


# --- Registre ---
EXPORTERS = {
    "c": CExporter(),
    "rust": RustExporter(),
    "go": GoExporter(),
}